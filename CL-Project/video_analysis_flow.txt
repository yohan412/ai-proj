Video Analysis Logic Flow
=========================

This document outlines the end-to-end process for uploading and analyzing a video file.

### Phase 1: The Upload (Browser)

1.  **Initiation:** A user on the `/analyze` page (`VidAnalyzer.html`) drags and drops a video file onto the upload area.
2.  **Frontend Event Handling (`VidAnalyzer.js`):** The `drop` event listener captures the video `File` object.
3.  **Upload Orchestration (`AnalyzerShare.js`):** The handler calls `AnalyzerShare.uploadVideos()`. This function retrieves the JWT, creates a `FormData` object with the file, and prepares a `fetch` request.
4.  **Fetch Interception (`auth-fetch.js`):** The `fetch` call is intercepted, and the `Authorization: Bearer <token>` header is automatically added.
5.  **Network Request:** The browser sends a `POST` request as `multipart/form-data` to the `/api/videos/upload` endpoint on the Java backend.

### Phase 2: Initial Reception (Java Backend)

1.  **Controller Entry Point (`VideoController.java`):** The `@PostMapping("/upload")` method is invoked.
2.  **Duplicate Check (`FileCompareUtil.java`):** The controller checks if the exact same file content has been uploaded before by comparing file sizes and SHA-256 hashes. If a match is found, the existing Job ID is returned, and the process stops here.
3.  **Asynchronous Task Delegation (`VideoAnalysisServiceImpl.java`):** For a new video, the `analyzeVideo` method is called. It does not perform the analysis directly.
    *   It generates a unique Job ID.
    *   It creates a `CompletableFuture` to hold the eventual result.
    *   It registers the job and future in the `InMemoryJobManager`.
    *   It immediately returns the `jobId` in the HTTP response to the browser.
4.  **Background Thread Execution:** The `@Async` `performAnalysis` method starts running in a separate background thread.

### Phase 3: The Analysis Pipeline (Java -> Python -> Disk)

1.  **File Persistence (Java):** The background thread saves the uploaded video to the `uploads/` directory (e.g., `uploads/user_video.mp4`).
2.  **Audio Extraction (Java -> FFmpeg):** It uses the FFmpeg command-line tool to extract the audio from the video file (e.g., `uploads/user_video.mp3`).
3.  **Handoff to Microservice (Java -> Python):** The Java service makes a `POST` request to the Python microservice at `http://localhost:5000/analyze`, providing the `jobId` and the path to the audio file.
4.  **Core Analysis (Python):** The Python service performs all the heavy lifting: audio transcription (Whisper), text-in-video extraction (CRAFT/PaddleOCR), and cognitive load calculation.
5.  **Saving Results to Disk (Python):** The Python service saves the results as separate JSON files in the shared `uploads/` directory, using the `jobId` as a prefix (e.g., `_transcript.json`, `_graph.json`).
6.  **Completing the Future (Java):** Upon receiving a `200 OK` from the Python service, the Java `performAnalysis` thread knows the files are ready. It finds the result files and completes the `CompletableFuture` with the paths to these JSON files.

### Phase 4: The Waiting Game (Browser <-> Java)

1.  **Polling Begins (`AnalyzerShare.js`):** After receiving the `jobId` in Phase 2, the browser starts a polling loop, sending a `GET` request to `/api/jobs/{jobId}/status` every 3 seconds.
2.  **Status Check (`AnalysisStatusController.java`):** The controller checks the job's status in the `InMemoryJobManager`. As long as the `CompletableFuture` is not complete, it returns a status of `RUNNING`.

### Phase 5: Displaying the Final Results (Java -> Browser)

1.  **Job Completion:** The `CompletableFuture` in the `InMemoryJobManager` is marked as `COMPLETED`.
2.  **Final Poll:** The browser's next polling request receives the `COMPLETED` status.
3.  **Fetching Result Data (`VidAnalyzer.js`):** The `onCompleted` callback triggers two final `GET` requests to the Java backend: `/api/jobs/{jobId}/graph` and `/api/jobs/{jobId}/cognitive-load`.
4.  **Serving Results (`AnalysisStatusController.java`):** The controller handles these requests by reading the raw content of the `_graph.json` and `_cognitive_load.json` files from the `uploads/` directory and sending it to the browser.
5.  **Client-Side Rendering (`VidAnalyzer.js`):** The browser receives the JSON data and uses it to render the D3.js and Chart.js graphs, displaying the final analysis to the user.
