<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>영상 편집 툴 (UI)</title>

  <style>
    :root{
      --bg:#2e3842; --panel:#242c35; --panel-2:#1f252c; --line:#3c4550;
      --text:#e7f1ff; --muted:#9fb3c8; --accent:#1f90ff; --marker:#1f90ff;
      --min-shell:1200px; --min-preview-h:420px; --min-timeline-h:180px;
    }
    *{ box-sizing:border-box; }
    body{ margin:0; background:var(--bg); color:#fff; font-family:Arial, Helvetica, sans-serif; }

    /* ===== 2열 레이아웃 + 최소 폭 보장 ===== */
    .editor-container{
      height:100vh; padding:24px; display:flex; justify-content:center; align-items:center;
      overflow-x:auto; overflow-y:hidden;
    }
    .editor-shell{
      width:100%; max-width:1400px; min-width:var(--min-shell); height:92vh;
      display:grid; gap:16px; grid-template-columns:minmax(700px,1fr) 560px;
    }

    /* ===== 왼쪽 편집기 ===== */
    .editor-inner{
      display:flex; flex-direction:column; height:100%;
      background:var(--panel-2); border:1px solid var(--line); border-radius:8px;
      overflow:hidden; box-shadow:0 0 10px rgba(0,0,0,.3); min-width:700px;
    }
    .preview-area{
      flex:1; position:relative; display:flex; align-items:center; justify-content:center;
      background:var(--panel-2); cursor:pointer; min-height:var(--min-preview-h);
    }
    .preview-area.dragover{ outline:2px dashed var(--accent); }
    .preview-area video, .preview-area img{
      max-height:100%; max-width:100%; object-fit:contain; border-radius:8px;
      box-shadow:0 4px 20px rgba(0,0,0,.5);
    }
    #video-input{ display:none; }

    /* ===== 타임라인 ===== */
    .timeline-container{
      position:relative; background:var(--panel);
      padding:40px 20px 20px; border-top:1px solid var(--line);
      min-height:var(--min-timeline-h);
    }
    .segment-bar{
      position:absolute; top:10px; left:20px; right:20px; height:6px;
      background:rgba(255,255,255,.3); border-radius:3px; z-index:2; cursor:pointer;
    }
    .segment-bar .handle{
      position:absolute; top:-4px; width:12px; height:14px; background:rgba(255,255,255,.85);
      border-radius:3px; cursor:ew-resize; z-index:3;
    }
    .segment-bar .handle.start{ left:0; }

    /* 세로 마커 + 겹치는 아래쪽 화살표 */
    .segment-bar .marker{
      position:absolute; top:-8px; width:2px; height:22px;
      background:var(--marker); border-radius:1px; z-index:4; cursor:ew-resize;
      box-shadow:0 0 6px rgba(31,144,255,.6);
    }
    .segment-bar .marker::after{
      content:""; position:absolute; left:50%; transform:translateX(-50%);
      top:-6px; width:0; height:0; pointer-events:none;
      border-left:7px solid transparent; border-right:7px solid transparent;
      border-top:10px solid var(--marker);  /* ▼ */
      filter:drop-shadow(0 0 4px rgba(31,144,255,.6));
    }
    .segment-bar .marker.active{
      background:#fff; box-shadow:0 0 10px rgba(31,144,255,.9); width:3px;
    }
    .segment-bar .marker.active::after{
      border-top-color:#fff; filter:drop-shadow(0 0 6px rgba(255,255,255,.9));
    }

    /* 시간 레이블 (좌/우 고정) */
    .time-label{ position:absolute; top:24px; font-size:12px; color:rgba(255,255,255,.85); z-index:2; }
    .time-label.start{ left:20px; }
    .time-label.end{ right:20px; }

    .timeline{ display:flex; align-items:center; gap:10px; margin-top:25px; overflow-x:auto; padding-bottom:4px; }
    .timeline-item{
      flex:0 0 auto; width:100px; height:100px; background:#3d4754; border-radius:6px;
      transition:transform .2s; overflow:hidden; position:relative; display:flex; align-items:center; justify-content:center;
      color:#c7d2de; font-size:12px; border:1px solid transparent; min-width:100px; min-height:100px;
    }
    .timeline-item:hover{ transform:scale(1.03); background:#505c6a; border-color:#637386; }
    .timeline-item img{ width:100%; height:100%; object-fit:cover; display:block; }

    /* 빈 상자: + 아이콘 중앙 */
    .timeline-item.empty::after{
      content:"+"; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
      font-size:36px; font-weight:700; color:#d3deeb; opacity:.85; line-height:1; pointer-events:none;
      text-shadow:0 0 6px rgba(31,144,255,.35);
    }
    .timeline-item.active{
      border-color:var(--accent); box-shadow:0 0 0 2px var(--accent), 0 0 16px rgba(31,144,255,.35) inset;
    }

    /* ===== 오른쪽 패널 ===== */
    .right-panel{
      background:var(--panel); border:1px solid var(--line); border-radius:8px;
      box-shadow:0 0 10px rgba(0,0,0,.3); display:flex; flex-direction:column;
      min-width:560px; overflow:auto;
    }
    .panel-header{
      padding:10px 12px; border-bottom:1px solid var(--line);
      font-size:12px; letter-spacing:2px; color:var(--muted);
      display:flex; align-items:center; justify-content:space-between;
    }
    .upload-row{
      display:flex; gap:8px; align-items:center; padding:10px 12px; border-bottom:1px solid var(--line);
    }
    .upload-row button{
      background:var(--accent); color:white; border:0; border-radius:6px;
      padding:8px 12px; cursor:pointer;
    }
    .upload-row .hint{ font-size:12px; color:#9fb3c8; margin-left:8px; }
    .status{ font-size:12px; color:#9fb3c8; padding:6px 12px; min-height:20px; }

    .vtext-preview{
      flex:1; margin:12px; min-height:120px; background:var(--panel-2);
      border:1px dashed var(--line); border-radius:6px; overflow:auto; padding:10px 12px;
    }
    pre.srt{ margin:0; white-space:pre-wrap; word-break:break-word;
      font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size:13px; color:#e7f1ff; }
  </style>
</head>
<body>
  <!-- 좌측 비디오 업로드 input (좌측 프리뷰용) -->
  <input type="file" id="video-input" accept="video/*" hidden>

  <div class="editor-container">
    <div class="editor-shell">
      <!-- ===== 왼쪽: 편집/타임라인 ===== -->
      <div class="editor-inner">
        <div class="preview-area" id="preview-area" title="클릭 또는 드래그&드롭으로 영상 불러오기">
          <img id="preview-media" alt="video preview"
               src="https://via.placeholder.com/360x640/000000/FFFFFF?text=PREVIEW"/>
        </div>

        <div class="timeline-container">
          <div class="segment-bar" id="segment-bar">
            <div class="handle start" id="start-handle"></div>
          </div>
          <span class="time-label start" id="time-label-start">0:00</span>
          <span class="time-label end" id="time-label-end">0:00</span>

          <div class="timeline" id="timeline">
            <div class="timeline-item empty" data-filled="false"></div>
          </div>
        </div>
      </div>

      <!-- ===== 오른쪽: 자막 추출 버튼 + SRT 미리보기 ===== -->
      <aside class="right-panel">
        <div class="panel-header"><span>TEXT</span></div>

        <div class="upload-row">
          <button id="btn-upload" type="button">자막 추출</button>
          <span class="hint">좌측에서 불러온 영상으로 자막을 추출합니다.</span>
        </div>
        <div class="status" id="status"></div>

        <div class="vtext-preview">
          <pre id="srt-view" class="srt">여기에 SRT 자막이 표시됩니다.</pre>
        </div>
      </aside>
    </div>
  </div>

  <script>
    /* ================= 좌측: 미리보기/타임라인 ================= */
    const fileInput = document.getElementById('video-input');
    const previewArea = document.getElementById('preview-area');
    const segmentBar = document.getElementById('segment-bar');
    const handle = document.getElementById('start-handle');
    const timeLabelStart = document.getElementById('time-label-start');
    const timeLabelEnd = document.getElementById('time-label-end');
    const timeline = document.getElementById('timeline');

    let videoEl, duration = 0, currentVideoFile = null;
    let idSeq = 1;
    const pairs = new Map(); // {id, time, markerEl, thumbEl}
    let activeId = null;

    // 좌측 프리뷰 클릭 → 파일 선택
    previewArea.addEventListener('click', (e)=>{
      if(e.target.tagName.toLowerCase()!=='video') fileInput.click();
    });

    // 드래그&드롭 지원
    previewArea.addEventListener('dragover', e=>{ e.preventDefault(); previewArea.classList.add('dragover'); });
    previewArea.addEventListener('dragleave', ()=> previewArea.classList.remove('dragover'));
    previewArea.addEventListener('drop', e=>{
      e.preventDefault(); previewArea.classList.remove('dragover');
      const f = e.dataTransfer.files?.[0];
      if(f && f.type.startsWith('video/')) loadVideo(f);
    });

    fileInput.addEventListener('change', e=>{
      const f = e.target.files?.[0];
      if(f && f.type.startsWith('video/')) loadVideo(f);
    });

    function loadVideo(file){
      currentVideoFile = file;                // ← 오른쪽 자막추출에 사용할 원본 파일 저장
      const url = URL.createObjectURL(file);
      previewArea.innerHTML = '';
      videoEl = document.createElement('video');
      videoEl.src = url;
      videoEl.controls = true;
      videoEl.style.maxHeight = '100%';
      videoEl.style.maxWidth  = '100%';
      videoEl.style.objectFit = 'contain';
      previewArea.appendChild(videoEl);

      videoEl.addEventListener('loadedmetadata', ()=>{
        duration = videoEl.duration || 0;
        updateTimeLabel(0, duration);
        bindSegmentEvents();
      }, { once:true });
    }

    function bindSegmentEvents(){
      segmentBar.addEventListener('click', e=>{
        const r = segmentBar.getBoundingClientRect();
        const offset = Math.min(Math.max(0, e.clientX - r.left), r.width);
        const t = duration * (offset / r.width);
        if(videoEl) videoEl.currentTime = t;
        handle.style.left = offset + 'px';
        updateTimeLabel(t, duration);
      });

      let sx, sl;
      handle.addEventListener('mousedown', e=>{
        e.preventDefault(); sx = e.clientX; sl = handle.offsetLeft;
        const move = m=>{
          const r = segmentBar.getBoundingClientRect();
          const nl = Math.min(Math.max(0, sl + (m.clientX - sx)), r.width);
          handle.style.left = nl + 'px';
          const t = duration * (nl / r.width);
          if(videoEl) videoEl.currentTime = t;
          updateTimeLabel(t, duration);
        };
        const up = ()=>{
          document.removeEventListener('mousemove', move);
          document.removeEventListener('mouseup', up);
        };
        document.addEventListener('mousemove', move);
        document.addEventListener('mouseup', up);
      });
    }

    function updateTimeLabel(start, end){
      const fmt = t => { const m = Math.floor(t/60); const s = Math.floor(t%60).toString().padStart(2,'0'); return `${m}:${s}`; };
      timeLabelStart.textContent = fmt(start);
      timeLabelEnd.textContent   = fmt(end);
    }

    // 썸네일 클릭 → 마커/페어 생성 & 프레임 캡처
    timeline.addEventListener('click', async (e)=>{
      const item = e.target.closest('.timeline-item');
      if(!item) return;

      const id = item.dataset.id ? Number(item.dataset.id) : null;
      if(id && pairs.has(id)){ setActive(id); return; }

      const mid = duration ? duration * 0.5 : 0;
      const newId = createPair(item, mid);
      setActive(newId);

      if(duration && videoEl){ await updateThumbFromTime(newId); }
      ensureTrailingEmptyThumb();
    });

    function createPair(thumbEl, time){
      const id = idSeq++;

      // marker
      const marker = document.createElement('div');
      marker.className = 'marker';
      marker.dataset.id = String(id);
      segmentBar.appendChild(marker);

      // thumbnail
      thumbEl.dataset.id = String(id);
      thumbEl.dataset.filled = 'true';
      thumbEl.classList.remove('empty');

      pairs.set(id, { id, time, markerEl: marker, thumbEl });
      positionMarker(marker, time);

      // marker drag & activate
      enableMarkerDrag(marker);
      marker.addEventListener('mousedown', ()=> setActive(id));
      marker.addEventListener('click', (e)=>{ e.stopPropagation(); setActive(id); });

      return id;
    }

    function setActive(id){
      activeId = id;
      document.querySelectorAll('.timeline-item').forEach(el=> el.classList.remove('active'));
      document.querySelectorAll('.segment-bar .marker').forEach(el=> el.classList.remove('active'));
      const p = pairs.get(id);
      if(p){ p.thumbEl.classList.add('active'); p.markerEl.classList.add('active'); }
    }

    function positionMarker(markerEl, time){
      const r = segmentBar.getBoundingClientRect();
      const frac = duration ? (time / duration) : 0;
      markerEl.style.left = Math.round(frac * r.width) + 'px';
    }

    function enableMarkerDrag(marker){
      let sx, sl, dragging = false;
      const id = Number(marker.dataset.id);

      const down = e=>{
        e.preventDefault(); dragging = true; sx = e.clientX; sl = marker.offsetLeft;
        setActive(id);
        document.addEventListener('mousemove', move);
        document.addEventListener('mouseup', up);
      };
      const move = e=>{
        if(!dragging) return;
        const r = segmentBar.getBoundingClientRect();
        const nl = Math.min(Math.max(0, sl + (e.clientX - sx)), r.width);
        marker.style.left = nl + 'px';
      };
      const up = async ()=>{
        if(!dragging) return; dragging = false;
        document.removeEventListener('mousemove', move);
        document.removeEventListener('mouseup', up);

        const r = segmentBar.getBoundingClientRect();
        const left = parseInt(marker.style.left||'0',10);
        const time = duration ? (left / r.width) * duration : 0;
        const p = pairs.get(id);
        if(p){ p.time = time; if(videoEl && duration) await updateThumbFromTime(id); }
      };

      marker.addEventListener('mousedown', down);
    }

    async function updateThumbFromTime(id){
      const p = pairs.get(id); if(!p) return;
      try{
        const url = await captureFrameAt(p.time);
        p.thumbEl.innerHTML = '';
        const img = document.createElement('img');
        img.src = url;
        p.thumbEl.appendChild(img);
      }catch(err){ console.error('frame capture error', err); }
    }

    function ensureTrailingEmptyThumb(){
      const last = timeline.lastElementChild;
      if(!last || last.dataset.filled === 'true'){
        const box = document.createElement('div');
        box.className = 'timeline-item empty';
        box.dataset.filled = 'false';
        timeline.appendChild(box);
      }
    }

    window.addEventListener('resize', ()=>{
      pairs.forEach(p => positionMarker(p.markerEl, p.time));
    });
